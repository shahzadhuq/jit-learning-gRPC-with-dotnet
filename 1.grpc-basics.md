# Learn gRPC (Remote Procedure Call)

## TL;DR

<details>
<summary>click to expand</summary>

1. [gRPC](https://grpc.io/docs/what-is-grpc/introduction/) is an open source Remote Procedure Call (RPC) framework created by Google and now part of the Cloud Native Computing Foundation (CNCF).
1. It was created to 1/ achieve low latency for service-to-service communication, 2/ be super efficient over low-power and low-bandwidth systems, 3/ be language/platform neutral.

1. gRPC's awesomeness is driven by three primary pillars
    1. Uses HTTP/2 as its underlying transport protocol and leverages HTTP/2 `multiplexing` capabilities to help reduce network latency and achieve more over fewer TCP connections.
    1. Uses an open-source protocol called [Protocol buffers (`protobuf`)](https://developers.google.com/protocol-buffers/docs/overview) to communicate which is more compact (smaller than JSON) and faster to serialize.
    1. gRPC takes service contract first approach and its tooling can auto-generate client/server code in different gPRC [supported language](https://grpc.io/docs/languages/). For example, server-side code in .NET, its client-side code in python, and interoperate using protobuf.

1. Also, gRPC could be a good target when modernizing WCF. Note, CoreWCF exists as well.

</details>

## Important Tangent (HTTP 1.1 and HTTP/2)

<details>
<summary>click to expand</summary>

gRPC takes advantage of HTTP/2 multiplexing capability to achieve great performance. Let’s understand it better.

### **HTTP 1.1**

Quick refresher of the familiar, HTTP 1.1.

<details>
<summary>click to expand</summary>

1. Over a single TCP connection, HTTP 1.1 supports a single request/response model between client (e.g. browser) and server.
1. This HTTP 1.1. commonly runs into Head-of-Line problem: over single TCP, new request has to wait for the previous request to complete before the client can make a new request.

1. Browsers can re-use single persistent TCP connection to fetch multiple resources, BUT one-by-one. Example, download main.js (request/response), then main.css, and so on.

1. And to fetch multiple resources in parallel - help improve performance - browsers must open and use multiple TCP connections (usually up to 6 connections per hostname).

    ![http1.1](./diagrams/http1.1.png)

</details>

### **HTTP/2**

HTTP/2 introduced new binary framing layer to 1/ help resolve head-of-line blocking problem found in HTTP/1.x and 2/ achieve parallel request/response processing over single TCP connection. Let's see how.

<details>
<summary>click to expand</summary>

1. HTTP/2 is designed with goals to 1/ reduce latency by multiplexing requests over the single TCP connection, 2/ minimize protocol overhead via efficient compression of HTTP header fields, 3/ support for request prioritization, and more.
    1. Leveraging HTTP/2 multiplexing, clients can make multiple requests to a server without having to wait for the previous ones to complete; the responses can arrive in any order.

1. HTTP 1.1 core concepts - example, HTTP methods, status codes, URIs - remain in place but HTTP/2 does modify data is exchanged between client/server via it's new binary framing layer.

1. HTTP/2 breaks down the HTTP protocol communication into an exchange of binary-encoded frames, which are then mapped to messages that belong to a particular stream, and all of which are multiplexed over a single TCP connection.

    > This is the foundation that enables all other features and performance optimizations provided by the HTTP/2 protocol.

1. Diagram below shows anatomy of the binary-encoded frames: `Stream`, `Message`, and `Frame`.
    1. Stream - A bidirectional flow of bytes within an established connection, which may carry one or more messages.
    1. Message - A complete sequence of frames that map to a logical request or response message.
    1. Frame - The smallest unit of communication in HTTP/2, each containing a frame header, which at a minimum identifies the stream to which the frame belongs.

    ![http2](./diagrams/http2.png)

</details>

</details>

## gRPC Core Concepts

<details>
<summary>click to expand</summary>

1. gRPC is an open-source framework designed for efficient communication between distributed services.
    1. gRPC does require HTTP/2 and TLS.

1. gRPC uses its custom protocol called [`Protocol Buffers`](https://developers.google.com/protocol-buffers/docs/overview) (*protobuf*) for both 1/ Interface Definition Language (IDL) and 2/ as its underlying message interchange format.
    1. FYI: gRPC can be used with other data formats such as JSON.
1. Compared to the JSON/XML, *protobuf* is more compact and faster to serialize but it isn't human readable (tooling exist to assist with this).
1. gRPC takes a contract-first approach to service (i.e. API) development. 
    1. This service contract is defined in an ordinary text file with a `.proto` extension.
1. In `.proto` file, you will use a *language neutral* syntax to define the contract of your service. For instance:
    1. Specify the methods that can be called remotely with their parameters.
    1. Strongly typed request/response message types (analogous to data models).

        ```c#
        // Example .proto file
    
        syntax = "proto3";
        
        // The greeting service definition.
        service Greeter {
          // Method: Sends a greeting
          rpc SayHello (HelloRequest) returns (HelloReply);
        }
        
        // The request message containing the user's name.
        message HelloRequest {
          string name = 1;
        }
        
        // The response message containing the greetings.
        message HelloReply {
          string message = 1;
        }
        ```

1. You will use gRPC tooling - protobuf complier called `protoc` - to compile the `.proto` file(s).
1. `protoc` compiler can generate code for the client/server. For instance, it will generate access classes in your preferred language (e.g. NET, Java, Python, and more):
    1. Methods defined by the service’s contract.
    1. Base class that will contain request/response message classes (i.e. Data Models).
    1. and more...

1. Unlike HTTP APIs, gRPC services cannot be called directly from the browser (as of June 2022).
    1. Approaches like gRPC-web, Transcoding (maps HTTP/JSON to gRPC methods), and gRPC-gateway make this use case possible. Reference [Modernization with gRPC](./3.modernization-with-grpc.md) section for more details.

1. Diagram below summarizes gRPC basics (source .NET)

    ![gRPC-basics](./diagrams/gRPC-basics.png)

</details>
