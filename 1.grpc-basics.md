# Learn gRPC (Remote Procedure Call)

## WHY gRPC

<details>
<summary>click to expand</summary>

1. [gRPC](https://grpc.io/docs/what-is-grpc/introduction/) is created to
    1. Achieve low latency for service-to-service communication in a large-scale distributed system (e.g. microservices).
    1. Be super efficient over low-power and low-bandwidth systems.
    1. Run anywhere; support multi language/platform environments. Example, client could be in `GO` and server could be in `.NET`.
    1. and more ...

1. gRPC fast performance results from
    1. Leveraging HTTP/2 `multiplexing` capabilities. Browsers can do more over fewer TCP connections (more on this later).
    1. Its custom protocol called Protocol Buffer (protobuf): its language-neutral, platform-neutral, and extensible mechanism for serializing structured data.

1. gRPC could be a good target when modernizing WCF. Note, CoreWCF exists as well.

</details>

## Important Tangent (HTTP 1.1 and HTTP/2)

<details>
<summary>click to expand</summary>

gRPC takes advantage of HTTP/2 multiplexing capability to achieve great performance. Let’s understand it better.

### **HTTP 1.1**

Quick refresher of the familiar, HTTP 1.1.

<details>
<summary>click to expand</summary>

1. HTTP 1.1, per TCP connection, only supports a single request/response at time model between client (e.g. browser) and server.
    1. Head-of-Line problem: over HTTP 1.1, doing a new request over one of these connections has to wait for the previous request on the same connection to complete before the client can make a new request.

1. Browsers can re-use single persistent TCP connection to fetch multiple resources BUT one-by-one. Example, download main.js (request/response), then main.css, and so on.

1. Now to fetch multiple resources in parallel - help improve performance - browsers must open and use multiple TCP connections (usually up to 6 connections per hostname).

    ![http1.1](./diagrams/http1.1.png)

</details>

### **HTTP/2**

HTTP/2 new binary framing layer resolves the head-of-line blocking problem found in HTTP/1.x and eliminates the need for multiple connections to enable parallel processing and delivery of requests and responses. This makes your applications faster and cheaper to deploy.

Let's see how.

<details>
<summary>click to expand</summary>

1. HTTP/2 is designed with goals to 1/ reduce latency by multiplexing requests over the single TCP connection, 2/ minimize protocol overhead via efficient compression of HTTP header fields, 3/ support for request prioritization, and more.
    1. Leveraging HTTP/2 multiplexing, clients can make multiple requests to a server without having to wait for the previous ones to complete; the responses can arrive in any order.

1. HTTP 1.1 core concepts - example, HTTP methods, status codes, URIs - remain in place but HTTP/2 does modify data is exchanged between client/server via it's new binary framing layer.

1. HTTP/2 breaks down the HTTP protocol communication into an exchange of binary-encoded frames, which are then mapped to messages that belong to a particular stream, and all of which are multiplexed over a single TCP connection.

    > This is the foundation that enables all other features and performance optimizations provided by the HTTP/2 protocol.

1. Diagram below shows anatomy of the binary-encoded frames: `Stream`, `Message`, and `Frame`.
    1. Stream - A bidirectional flow of bytes within an established connection, which may carry one or more messages.
    1. Message - A complete sequence of frames that map to a logical request or response message.
    1. Frame - The smallest unit of communication in HTTP/2, each containing a frame header, which at a minimum identifies the stream to which the frame belongs.

    ![http2](./diagrams/http2.png)

</details>

</details>

## gRPC Core Concepts

<details>
<summary>click to expand</summary>

1. gRPC is an open-source framework designed for efficient communication between distributed services.
    1. gRPC does require HTTP/2 and TLS.

1. gRPC uses its custom protocol called [`Protocol Buffers`](https://developers.google.com/protocol-buffers/docs/overview) (*protobuf*) for both 1/ Interface Definition Language (IDL) and 2/ as its underlying message interchange format.
    1. FYI: gRPC can be used with other data formats such as JSON.
1. Compared to the JSON/XML, *protobuf* is more compact and faster to serialize but it isn't human readable (tooling exist to assist with this).
1. gRPC takes a contract-first approach to service (i.e. API) development. 
    1. This service contract is defined in an ordinary text file with a `.proto` extension.
1. In `.proto` file, you will use a *language neutral* syntax to define the contract of your service. For instance:
    1. Specify the methods that can be called remotely with their parameters.
    1. Strongly typed request/response message types (analogous to data models).

        ```c#
        // Example .proto file
    
        syntax = "proto3";
        
        // The greeting service definition.
        service Greeter {
          // Method: Sends a greeting
          rpc SayHello (HelloRequest) returns (HelloReply);
        }
        
        // The request message containing the user's name.
        message HelloRequest {
          string name = 1;
        }
        
        // The response message containing the greetings.
        message HelloReply {
          string message = 1;
        }
        ```

1. You will use gRPC tooling - protobuf complier called `protoc` - to compile the `.proto` file(s).
1. `protoc` compiler can generate code for the client/server. For instance, it will generate access classes in your preferred language (e.g. NET, Java, Python, and more):
    1. Methods defined by the service’s contract.
    1. Base class that will contain request/response message classes (i.e. Data Models).
    1. and more...

1. Unlike HTTP APIs, gRPC services cannot be called directly from the browser (as of June 2022).
    1. Approaches like gRPC-web, Transcoding (maps HTTP/JSON to gRPC methods), and gRPC-gateway make this use case possible. Reference [Modernization with gRPC](./3.modernization-with-grpc.md) section for more details.

1. Diagram below summarizes gRPC basics (source .NET)

    ![gRPC-basics](./diagrams/gRPC-basics.png)

</details>
